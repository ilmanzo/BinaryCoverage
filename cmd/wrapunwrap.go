package main

import (
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const (
	wrapperIDComment        = "# Pin Wrapper generated by Go tool funkoverage"
	defaultPinToolSearchDir = "/usr/lib64/coverage-tools"
	defaultLogDir           = "/var/coverage/data"
	defaultSafeBinDir       = "/var/coverage/bin"
)

// --- Wrapper Management ---

func isELF(path string) bool {
	f, err := os.Open(path)
	if err != nil {
		return false
	}
	defer f.Close()
	magic := make([]byte, 4)
	if _, err := f.Read(magic); err != nil {
		return false
	}
	return string(magic) == "\x7fELF"
}

// move attempts to rename a file, falling back to copying if it fails due to cross-device link issues.
func move(source, destination string) error {
	err := os.Rename(source, destination)
	if err != nil && strings.Contains(err.Error(), "invalid cross-device link") {
		return moveCrossDevice(source, destination)
	}
	return err
}

func moveCrossDevice(source, destination string) error {
	src, err := os.Open(source)
	if err != nil {
		return fmt.Errorf("open(source): %w", err)
	}
	dst, err := os.Create(destination)
	if err != nil {
		src.Close()
		return fmt.Errorf("create(destination): %w", err)
	}
	_, err = io.Copy(dst, src)
	src.Close()
	dst.Close()
	if err != nil {
		return fmt.Errorf("copy: %w", err)
	}
	fi, err := os.Stat(source)
	if err != nil {
		os.Remove(destination)
		return fmt.Errorf("stat: %w", err)
	}
	err = os.Chmod(destination, fi.Mode())
	if err != nil {
		os.Remove(destination)
		return fmt.Errorf("chmod: %w", err)
	}
	os.Remove(source)
	return nil
}

func wrap(targetBinary string) error {
	PIN_ROOT := os.Getenv("PIN_ROOT")
	if PIN_ROOT == "" {
		return errors.New("PIN_ROOT environment variable is not set")
	}
	PIN_TOOL_SEARCH_DIR := os.Getenv("PIN_TOOL_SEARCH_DIR")
	if PIN_TOOL_SEARCH_DIR == "" {
		PIN_TOOL_SEARCH_DIR = defaultPinToolSearchDir
	}
	LOG_DIR := os.Getenv("LOG_DIR")
	if LOG_DIR == "" {
		LOG_DIR = defaultLogDir
	}
	SAFE_BIN_DIR := os.Getenv("SAFE_BIN_DIR")
	if SAFE_BIN_DIR == "" {
		SAFE_BIN_DIR = defaultSafeBinDir
	}
	pinTool, err := findPinTool(PIN_TOOL_SEARCH_DIR)
	if err != nil {
		return err
	}
	realTarget, err := filepath.EvalSymlinks(targetBinary)
	if err != nil {
		return fmt.Errorf("could not resolve symlink: %w", err)
	}
	targetBinary = realTarget
	content, err := os.ReadFile(targetBinary)
	if err != nil {
		return fmt.Errorf("could not read target: %w", err)
	}
	if strings.Contains(string(content), wrapperIDComment) {
		return fmt.Errorf("'%s' is already a wrapper. Use unwrap first", targetBinary)
	}
	// --- ELF check here ---
	if !isELF(targetBinary) {
		return fmt.Errorf("'%s' is not an ELF executable (maybe a script?). Aborting", targetBinary)
	}
	if err := os.MkdirAll(SAFE_BIN_DIR, 0755); err != nil {
		return err
	}
	tmpDir, err := os.MkdirTemp(SAFE_BIN_DIR, "*")
	if err != nil {
		return err
	}
	// change tmpdir permissions to allow execution from all users
	if err := os.Chmod(tmpDir, 0755); err != nil {
		return fmt.Errorf("could not set permissions on temp dir: %w", err)
	}
	// Move the original binary to a safe location
	binaryName := filepath.Base(targetBinary)
	movedBinaryPath := filepath.Join(tmpDir, binaryName)
	if err := move(targetBinary, movedBinaryPath); err != nil {
		return err
	}
	wrapperScript := fmt.Sprintf(`#!/bin/bash
%s on %s
# Original Binary: %s

PIN_ROOT="${PIN_ROOT:-%s}"
PIN_TOOL="%s"
LOG_DIR="%s"
ORIGINAL_BINARY="%s"

mkdir -m 0777 -p "$LOG_DIR"

binary_name=$(basename "$0")
timestamp=$(date "+%%Y%%m%%d-%%H%%M%%S")
nano_seconds=$(date "+%%N")
log_file="$LOG_DIR/${binary_name}_${timestamp}_${nano_seconds}.log"

exec "/usr/bin/pin" -follow_execv -t "$PIN_TOOL" -logfile "$log_file" -- "$ORIGINAL_BINARY" "$@"
`, wrapperIDComment, time.Now().Format(time.RFC3339), movedBinaryPath, PIN_ROOT, pinTool, LOG_DIR, movedBinaryPath)
	if err := os.WriteFile(targetBinary, []byte(wrapperScript), 0755); err != nil {
		return err
	}
	fmt.Printf("Wrapped %s (original moved to %s)\n", targetBinary, movedBinaryPath)
	return nil
}

func unwrap(targetBinary string) error {
	content, err := os.ReadFile(targetBinary)
	if err != nil {
		return fmt.Errorf("could not read wrapper: %w", err)
	}
	if !strings.Contains(string(content), wrapperIDComment) {
		return fmt.Errorf("'%s' is not a valid wrapper script. Nothing to unwrap", targetBinary)
	}
	var origPath string
	for _, line := range strings.Split(string(content), "\n") {
		if strings.HasPrefix(line, "# Original Binary:") {
			origPath = strings.TrimSpace(strings.TrimPrefix(line, "# Original Binary:"))
			break
		}
	}
	if origPath == "" {
		return errors.New("could not find original binary path in wrapper")
	}
	if _, err := os.Stat(origPath); err != nil {
		return fmt.Errorf("original binary not found: %w", err)
	}
	if err := move(origPath, targetBinary); err != nil {
		return fmt.Errorf("could not restore original binary: %w", err)
	}
	_ = os.Remove(filepath.Dir(origPath))
	fmt.Printf("Unwrapped %s (restored original from %s)\n", targetBinary, origPath)
	return nil
}

func findPinTool(searchDir string) (string, error) {
	var found string
	_ = filepath.WalkDir(searchDir, func(path string, d os.DirEntry, err error) error {
		if d != nil && d.Name() == "FuncTracer.so" {
			found = path
			return io.EOF // stop walking
		}
		return nil
	})
	if found == "" {
		return "", errors.New("FuncTracer.so not found. Look for it in the $PIN_TOOL_SEARCH_DIR env variable or " + defaultPinToolSearchDir + " directory")
	}
	return found, nil
}

func wrapMany(binaries []string) error {
	var failed []string
	for _, bin := range binaries {
		if err := wrap(bin); err != nil {
			fmt.Fprintf(os.Stderr, "wrap error for %s: %v\n", bin, err)
			failed = append(failed, bin)
		}
	}
	if len(failed) > 0 {
		return fmt.Errorf("failed to wrap: %v", failed)
	}
	return nil
}

func unwrapMany(binaries []string) error {
	var failed []string
	for _, bin := range binaries {
		if err := unwrap(bin); err != nil {
			fmt.Fprintf(os.Stderr, "unwrap error for %s: %v\n", bin, err)
			failed = append(failed, bin)
		}
	}
	if len(failed) > 0 {
		return fmt.Errorf("failed to unwrap: %v", failed)
	}
	return nil
}
