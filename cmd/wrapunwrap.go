package main

import (
	"bytes"
	"debug/elf"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const (
	wrapperIDComment        = "# Pin Wrapper generated by Go tool funkoverage"
	defaultPinToolSearchDir = "/usr/lib64/coverage-tools"
	defaultLogDir           = "/var/coverage/data"
	defaultSafeBinDir       = "/var/coverage/bin"
)

var globalDebugRoot = "/usr/lib/debug"

// --- Wrapper Management ---

// checks if a binary is actually an ELF executable (and not a script)
func isELF(path string) bool {
	f, err := os.Open(path)
	if err != nil {
		return false
	}
	defer f.Close()
	magic := make([]byte, 4)
	if _, err := f.Read(magic); err != nil {
		return false
	}
	return string(magic) == "\x7fELF"
}

// checks if a binary has embedded debug symbols OR
// if it links to a valid, existing external debug file via Build ID.
func hasDebugInfo(path string) (bool, error) {
	f, err := elf.Open(path)
	if err != nil {
		return false, fmt.Errorf("failed to open elf: %w", err)
	}
	defer f.Close()

	// 1. Check for Embedded Symbols
	// DWARF sections usually start with .debug_ or .zdebug_ (compressed)
	for _, section := range f.Sections {
		if strings.HasPrefix(section.Name, ".debug_") || strings.HasPrefix(section.Name, ".zdebug_") {
			// Ensure it actually has data
			if section.Size > 0 {
				return true, nil // Found embedded symbols
			}
		}
	}

	// 2. Check for External Symbols via Build ID
	// If we are here, it is likely "stripped". We need to find the Build ID note.
	buildID, err := getBuildID(f)
	if err != nil {
		return false, nil // No Build ID found, so definitely no debug info
	}

	// 3. Verify the external file actually exists
	// Standard path: /usr/lib/debug/.build-id/xx/xxxx.debug
	if len(buildID) > 2 {
		debugPath := fmt.Sprintf("%s/.build-id/%s/%s.debug", globalDebugRoot, buildID[:2], buildID[2:])
		if _, err := os.Stat(debugPath); err == nil {
			return true, nil // Found linked symbols
		}
	}

	return false, nil
}

// Helper to parse the ELF Note and extract the raw Build ID bytes
func getBuildID(f *elf.File) (string, error) {
	// The Build ID is typically in a section named ".note.gnu.build-id"
	sec := f.Section(".note.gnu.build-id")
	if sec == nil {
		return "", fmt.Errorf("no build-id section")
	}

	data, err := sec.Data()
	if err != nil {
		return "", err
	}

	// Parse ELF Note format:
	// namesz (4 bytes) | descsz (4 bytes) | type (4 bytes) | name ... | desc ...
	// We expect name to be "GNU\0" (4 bytes)

	if len(data) < 16 { // Minimum size for header + empty desc
		return "", fmt.Errorf("malformed note")
	}

	var namesz, descsz, noteType uint32
	reader := bytes.NewReader(data)

	binary.Read(reader, f.ByteOrder, &namesz)
	binary.Read(reader, f.ByteOrder, &descsz)
	binary.Read(reader, f.ByteOrder, &noteType)

	// Verify it is a GNU Build ID
	// namesz should be 4 ("GNU\0") and type should be 3 (NT_GNU_BUILD_ID)
	if namesz != 4 || noteType != 3 {
		return "", fmt.Errorf("not a gnu build id note")
	}

	// Skip the name ("GNU\0") to get to the description (the hash)
	// namesz is 4 bytes, which is 4-byte aligned, so we just skip 4 bytes.
	// Current offset is 12. 12 + 4 = 16.
	return hex.EncodeToString(data[16 : 16+descsz]), nil
}

// attempts to rename a file, falling back to copying if it fails due to cross-device link issues.
func move(source, destination string) error {
	err := os.Rename(source, destination)
	if err != nil && strings.Contains(err.Error(), "invalid cross-device link") {
		return moveCrossDevice(source, destination)
	}
	return err
}

func moveCrossDevice(source, destination string) error {
	src, err := os.Open(source)
	if err != nil {
		return fmt.Errorf("open(source): %w", err)
	}
	dst, err := os.Create(destination)
	if err != nil {
		src.Close()
		return fmt.Errorf("create(destination): %w", err)
	}
	_, err = io.Copy(dst, src)
	src.Close()
	dst.Close()
	if err != nil {
		return fmt.Errorf("copy: %w", err)
	}
	fi, err := os.Stat(source)
	if err != nil {
		os.Remove(destination)
		return fmt.Errorf("stat: %w", err)
	}
	err = os.Chmod(destination, fi.Mode())
	if err != nil {
		os.Remove(destination)
		return fmt.Errorf("chmod: %w", err)
	}
	os.Remove(source)
	return nil
}

func wrap(targetBinary string) error {
	PIN_ROOT := os.Getenv("PIN_ROOT")
	if PIN_ROOT == "" {
		return errors.New("PIN_ROOT environment variable is not set")
	}
	PIN_TOOL_SEARCH_DIR := os.Getenv("PIN_TOOL_SEARCH_DIR")
	if PIN_TOOL_SEARCH_DIR == "" {
		PIN_TOOL_SEARCH_DIR = defaultPinToolSearchDir
	}
	LOG_DIR := os.Getenv("LOG_DIR")
	if LOG_DIR == "" {
		LOG_DIR = defaultLogDir
	}
	SAFE_BIN_DIR := os.Getenv("SAFE_BIN_DIR")
	if SAFE_BIN_DIR == "" {
		SAFE_BIN_DIR = defaultSafeBinDir
	}
	pinTool, err := findPinTool(PIN_TOOL_SEARCH_DIR)
	if err != nil {
		return err
	}

	// Check if the target is a symlink to preserve the calling name for multicall binaries
	fileInfo, err := os.Lstat(targetBinary)
	if err != nil {
		return fmt.Errorf("lstat failed for %s: %w", targetBinary, err)
	}
	isSymlink := (fileInfo.Mode() & os.ModeSymlink) != 0
	originalName := filepath.Base(targetBinary)

	realTarget, err := filepath.EvalSymlinks(targetBinary)
	if err != nil {
		return fmt.Errorf("could not resolve symlink: %w", err)
	}
	targetBinary = realTarget
	content, err := os.ReadFile(targetBinary)
	if err != nil {
		return fmt.Errorf("could not read target: %w", err)
	}
	if strings.Contains(string(content), wrapperIDComment) {
		return fmt.Errorf("'%s' is already a wrapper. Use unwrap first", targetBinary)
	}
	// --- ELF check here ---
	if !isELF(targetBinary) {
		return fmt.Errorf("'%s' is not an ELF executable (maybe a script?). Aborting", targetBinary)
	}
	// --- is debug information available --- ?
	found, err := hasDebugInfo(targetBinary)
	if err != nil {
		return fmt.Errorf("could not determine debug information for '%s': %w", targetBinary, err)
	}
	if !found {
		return fmt.Errorf("'%s' does not contain debug information. Aborting", targetBinary)
	}

	if err := os.MkdirAll(SAFE_BIN_DIR, 0755); err != nil {
		return err
	}
	tmpDir, err := os.MkdirTemp(SAFE_BIN_DIR, "*")
	if err != nil {
		return err
	}
	// change tmpdir permissions to allow execution from all users
	if err := os.Chmod(tmpDir, 0755); err != nil {
		return fmt.Errorf("could not set permissions on temp dir: %w", err)
	}
	// Move the original binary to a safe location
	binaryName := filepath.Base(targetBinary)
	movedBinaryPath := filepath.Join(tmpDir, binaryName)
	if err := move(targetBinary, movedBinaryPath); err != nil {
		return err
	}

	binaryToRun := movedBinaryPath
	if isSymlink && originalName != binaryName {
		symlinkPath := filepath.Join(tmpDir, originalName)
		if err := os.Symlink(binaryName, symlinkPath); err != nil {
			fmt.Printf("Warning: failed to create multicall symlink %s -> %s: %v\n", symlinkPath, binaryName, err)
		} else {
			binaryToRun = symlinkPath
		}
	}

	wrapperScript := fmt.Sprintf(`#!/bin/bash
%s on %s
# Original Binary: %s

PIN_ROOT="${PIN_ROOT:-%s}"
PIN_TOOL="%s"
LOG_DIR="%s"
ORIGINAL_BINARY="%s"

mkdir -m 0777 -p "$LOG_DIR"

binary_name=$(basename "$0")
timestamp=$(date "+%%Y%%m%%d-%%H%%M%%S")
nano_seconds=$(date "+%%N")
log_file="$LOG_DIR/${binary_name}_${timestamp}_${nano_seconds}.log"

exec "$PIN_ROOT/pin" -follow_execv -t "$PIN_TOOL" -logfile "$log_file" -- "$ORIGINAL_BINARY" "$@"
`, wrapperIDComment, time.Now().Format(time.RFC3339), movedBinaryPath, PIN_ROOT, pinTool, LOG_DIR, binaryToRun)
	if err := os.WriteFile(targetBinary, []byte(wrapperScript), 0755); err != nil {
		return err
	}
	fmt.Printf("Wrapped %s (original moved to %s)\n", targetBinary, movedBinaryPath)
	return nil
}

func unwrap(targetBinary string) error {
	// Resolve symlinks to ensure we are operating on the actual wrapper file
	realTarget, err := filepath.EvalSymlinks(targetBinary)
	if err != nil {
		return fmt.Errorf("could not resolve symlink: %w", err)
	}
	targetBinary = realTarget

	content, err := os.ReadFile(targetBinary)
	if err != nil {
		return fmt.Errorf("could not read wrapper: %w", err)
	}
	if !strings.Contains(string(content), wrapperIDComment) {
		return fmt.Errorf("'%s' is not a valid wrapper script. Nothing to unwrap", targetBinary)
	}
	var origPath string
	for _, line := range strings.Split(string(content), "\n") {
		if strings.HasPrefix(line, "# Original Binary:") {
			origPath = strings.TrimSpace(strings.TrimPrefix(line, "# Original Binary:"))
			break
		}
	}
	if origPath == "" {
		return errors.New("could not find original binary path in wrapper")
	}

	// Check if the backup binary path is a symlink (multicall binary case)
	fi, err := os.Lstat(origPath)
	if err != nil {
		return fmt.Errorf("original binary not found at %s: %w", origPath, err)
	}

	sourcePath := origPath
	if (fi.Mode() & os.ModeSymlink) != 0 {
		// It's a symlink, resolve it to find the real binary
		realPath, err := filepath.EvalSymlinks(origPath)
		if err != nil {
			return fmt.Errorf("failed to resolve symlink %s: %w", origPath, err)
		}
		// Remove the symlink so the directory can be empty after we move the binary
		if err := os.Remove(origPath); err != nil {
			fmt.Printf("Warning: failed to remove symlink %s: %v\n", origPath, err)
		}
		sourcePath = realPath
	}

	if err := move(sourcePath, targetBinary); err != nil {
		return fmt.Errorf("could not restore original binary: %w", err)
	}
	_ = os.Remove(filepath.Dir(sourcePath))
	fmt.Printf("Unwrapped %s (restored original from %s)\n", targetBinary, sourcePath)
	return nil
}

func findPinTool(searchDir string) (string, error) {
	var found string
	_ = filepath.WalkDir(searchDir, func(path string, d os.DirEntry, err error) error {
		if d != nil && d.Name() == "FuncTracer.so" {
			found = path
			return io.EOF // stop walking
		}
		return nil
	})
	if found == "" {
		return "", errors.New("FuncTracer.so not found. Look for it in the $PIN_TOOL_SEARCH_DIR env variable or " + defaultPinToolSearchDir + " directory")
	}
	return found, nil
}

func wrapMany(binaries []string) error {
	var failed []string
	for _, bin := range binaries {
		if err := wrap(bin); err != nil {
			fmt.Fprintf(os.Stderr, "wrap error for %s: %v\n", bin, err)
			failed = append(failed, bin)
		}
	}
	if len(failed) > 0 {
		return fmt.Errorf("failed to wrap: %v", failed)
	}
	return nil
}

func unwrapMany(binaries []string) error {
	var failed []string
	for _, bin := range binaries {
		if err := unwrap(bin); err != nil {
			fmt.Fprintf(os.Stderr, "unwrap error for %s: %v\n", bin, err)
			failed = append(failed, bin)
		}
	}
	if len(failed) > 0 {
		return fmt.Errorf("failed to unwrap: %v", failed)
	}
	return nil
}
