package main

import (
	"bufio"
	"encoding/xml"
	"errors"
	"fmt"
	"html/template"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

const (
	versionString    = "0.3"
	wrapperIDComment = "# Pin Wrapper generated by Go tool"
	htmlTemplateStr  = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Coverage Report for {{.ImageName}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2em; background: #f9f9f9; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 2em; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);}
        .summary { background: #f4f4f4; padding: 1.5em; border-radius: 8px; margin-bottom: 2em; border: 1px solid #ddd;}
        .summary .percentage { font-size: 1.8em; font-weight: bold; color: #0056b3;}
        .progress-bar { background: #e9ecef; border-radius: 50px; overflow: hidden; height: 30px; margin-top: 1em;}
        .progress-bar-inner { background: #28a745; height: 100%; color: white, text-align: center; line-height: 30px; font-weight: bold; transition: width 0.5s;}
        .function-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1em; list-style-type: none; padding: 0;}
        .function-list li { padding: 0.6em; border-radius: 5px; font-family: monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: transform 0.2s;}
        .function-list li:hover { transform: translateY(-2px); box-shadow: 0 2px 4px rgba(0,0,0,0.08);}
        .called { background: #d4edda; color: #155724; border-left: 5px solid #28a745;}
        .uncalled { background: #f8d7da; color: #721c24; border-left: 5px solid #dc3545;}
    </style>
</head>
<body>
<div class="container">
    <h1>Coverage Report</h1>
    <h2>Image: {{.ImageName}}</h2>
    <div class="summary">
        <p><strong>Total Functions:</strong> {{.TotalCount}}</p>
        <p><strong>Called Functions:</strong> {{.CalledCount}}</p>
        <p><strong>Uncalled Functions:</strong> {{.UncalledCount}}</p>
        <p class="percentage">Coverage: {{printf "%.2f" .CoveragePercentage}}%</p>
        <div class="progress-bar">
            <div class="progress-bar-inner" style="width: {{.CoveragePercentage}}%">{{printf "%.2f" .CoveragePercentage}}%</div>
        </div>
    </div>
    <details>
    <summary><h2>Function Details</h2></summary>
    <p><strong>Legend: </strong><span class="called"> Called Function </span><span class="uncalled"> Uncalled Function </span></p>
    <ul class="function-list">
        {{range .Functions}}
        <li class="{{.Status}}" title="{{.Name}}">{{.Name}}</li>
        {{end}}
    </ul>
    </details>
</div>
</body>
</html>`
)

type CoverageData struct {
	TotalFunctions  map[string]struct{}
	CalledFunctions map[string]struct{}
}

type FunctionEntry struct {
	Name   string
	Status string // "called" or "uncalled"
}

type HTMLReportData struct {
	ImageName          string
	TotalCount         int
	CalledCount        int
	UncalledCount      int
	CoveragePercentage float64
	Functions          []FunctionEntry
}

// --- Wrapper Management ---

func isELF(path string) bool {
	f, err := os.Open(path)
	if err != nil {
		return false
	}
	defer f.Close()
	magic := make([]byte, 4)
	if _, err := f.Read(magic); err != nil {
		return false
	}
	return string(magic) == "\x7fELF"
}

func wrap(targetBinary string) error {
	PIN_ROOT := os.Getenv("PIN_ROOT")
	if PIN_ROOT == "" {
		return errors.New("PIN_ROOT environment variable is not set")
	}
	PIN_TOOL_SEARCH_DIR := os.Getenv("PIN_TOOL_SEARCH_DIR")
	if PIN_TOOL_SEARCH_DIR == "" {
		PIN_TOOL_SEARCH_DIR = "/usr/lib64/coverage-tools"
	}
	LOG_DIR := os.Getenv("LOG_DIR")
	if LOG_DIR == "" {
		LOG_DIR = "/var/coverage/data"
	}
	SAFE_BIN_DIR := os.Getenv("SAFE_BIN_DIR")
	if SAFE_BIN_DIR == "" {
		SAFE_BIN_DIR = "/var/coverage/bin"
	}
	pinTool, err := findPinTool(PIN_TOOL_SEARCH_DIR)
	if err != nil {
		return err
	}
	realTarget, err := filepath.EvalSymlinks(targetBinary)
	if err != nil {
		return fmt.Errorf("could not resolve symlink: %w", err)
	}
	targetBinary = realTarget
	content, err := os.ReadFile(targetBinary)
	if err != nil {
		return fmt.Errorf("could not read target: %w", err)
	}
	if strings.Contains(string(content), wrapperIDComment) {
		return fmt.Errorf("'%s' is already a wrapper. Use unwrap first", targetBinary)
	}
	// --- ELF check here ---
	if !isELF(targetBinary) {
		return fmt.Errorf("'%s' is not an ELF executable (maybe a script?). Aborting.", targetBinary)
	}
	if err := os.MkdirAll(SAFE_BIN_DIR, 0755); err != nil {
		return err
	}
	tmpDir, err := os.MkdirTemp(SAFE_BIN_DIR, "origbin-")
	if err != nil {
		return err
	}
	binaryName := filepath.Base(targetBinary)
	movedBinaryPath := filepath.Join(tmpDir, binaryName)
	if err := os.Rename(targetBinary, movedBinaryPath); err != nil {
		return err
	}
	wrapperScript := fmt.Sprintf(`#!/bin/bash
%s on %s
# Original Binary: %s

PIN_ROOT="${PIN_ROOT:-%s}"
PIN_TOOL="%s"
LOG_DIR="%s"
ORIGINAL_BINARY="%s"

mkdir -p "$LOG_DIR"

binary_name=$(basename "$0")
timestamp=$(date "+%%Y%%m%%d-%%H%%M%%S")
nano_seconds=$(date "+%%N")
log_file="$LOG_DIR/${binary_name}_${timestamp}_${nano_seconds}.log"

exec "$PIN_ROOT/pin" -t "$PIN_TOOL" -logfile "$log_file" -- "$ORIGINAL_BINARY" "$@"
`, wrapperIDComment, time.Now().Format(time.RFC3339), movedBinaryPath, PIN_ROOT, pinTool, LOG_DIR, movedBinaryPath)
	if err := os.WriteFile(targetBinary, []byte(wrapperScript), 0755); err != nil {
		return err
	}
	fmt.Printf("Wrapped %s (original moved to %s)\n", targetBinary, movedBinaryPath)
	return nil
}

func unwrap(targetBinary string) error {
	content, err := os.ReadFile(targetBinary)
	if err != nil {
		return fmt.Errorf("could not read wrapper: %w", err)
	}
	if !strings.Contains(string(content), wrapperIDComment) {
		return fmt.Errorf("'%s' is not a valid wrapper script. Nothing to unwrap", targetBinary)
	}
	var origPath string
	for _, line := range strings.Split(string(content), "\n") {
		if strings.HasPrefix(line, "# Original Binary:") {
			origPath = strings.TrimSpace(strings.TrimPrefix(line, "# Original Binary:"))
			break
		}
	}
	if origPath == "" {
		return errors.New("could not find original binary path in wrapper")
	}
	if _, err := os.Stat(origPath); err != nil {
		return fmt.Errorf("original binary not found: %w", err)
	}
	if err := os.Rename(origPath, targetBinary); err != nil {
		return fmt.Errorf("could not restore original binary: %w", err)
	}
	_ = os.Remove(filepath.Dir(origPath))
	fmt.Printf("Unwrapped %s (restored original from %s)\n", targetBinary, origPath)
	return nil
}

func findPinTool(searchDir string) (string, error) {
	var found string
	_ = filepath.WalkDir(searchDir, func(path string, d os.DirEntry, err error) error {
		if d != nil && d.Name() == "FuncTracer.so" {
			found = path
			return io.EOF // stop walking
		}
		return nil
	})
	if found == "" {
		return "", errors.New("FuncTracer.so not found")
	}
	return found, nil
}

// --- Coverage Analysis ---

var (
	functionDefRe  = regexp.MustCompile(`\[Image:(.*?)\] \[Function:(.*?)\]`)
	functionCallRe = regexp.MustCompile(`\[Image:(.*?)\] \[Called:(.*?)\]`)
)

func analyzeLogs(logFiles []string) (map[string]*CoverageData, error) {
	coverage := make(map[string]*CoverageData)
	for _, logFile := range logFiles {
		f, err := os.Open(logFile)
		if err != nil {
			return nil, fmt.Errorf("could not open log file %s: %w", logFile, err)
		}
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			line := scanner.Text()
			if m := functionDefRe.FindStringSubmatch(line); m != nil {
				image, function := strings.TrimSpace(m[1]), strings.TrimSpace(m[2])
				if image == "" || function == "" {
					continue
				}
				if _, ok := coverage[image]; !ok {
					coverage[image] = &CoverageData{make(map[string]struct{}), make(map[string]struct{})}
				}
				coverage[image].TotalFunctions[function] = struct{}{}
			} else if m := functionCallRe.FindStringSubmatch(line); m != nil {
				image, function := strings.TrimSpace(m[1]), strings.TrimSpace(m[2])
				if image == "" || function == "" {
					continue
				}
				if _, ok := coverage[image]; !ok {
					coverage[image] = &CoverageData{make(map[string]struct{}), make(map[string]struct{})}
				}
				coverage[image].CalledFunctions[function] = struct{}{}
			}
		}
		f.Close()
	}
	return coverage, nil
}

func printTxtReport(coverage map[string]*CoverageData) {
	for image, data := range coverage {
		total := len(data.TotalFunctions)
		called := len(data.CalledFunctions)
		uncalled := total - called
		coveragePct := 0.0
		if total > 0 {
			coveragePct = float64(called) / float64(total) * 100
		}
		fmt.Printf("\n==================================================\n")
		fmt.Printf("Image: %s\n", image)
		fmt.Printf("==================================================\n")
		fmt.Printf("  Functions Found:   %d\n", total)
		fmt.Printf("  Functions Called:  %d\n", called)
		fmt.Printf("  Coverage:          %.2f%%\n", coveragePct)
		fmt.Printf("--------------------------------------------------\n")
		if called > 0 {
			fmt.Println("  Called Functions:")
			for fn := range data.CalledFunctions {
				fmt.Printf("    - %s\n", fn)
			}
		} else {
			fmt.Println("  No functions were called for this image.")
		}
		if uncalled > 0 {
			fmt.Println("\n  Uncalled Functions:")
			for fn := range data.TotalFunctions {
				if _, ok := data.CalledFunctions[fn]; !ok {
					fmt.Printf("    - %s\n", fn)
				}
			}
		}
	}
	fmt.Println("\n--- End of Console Report ---")
}

func generateHTMLReport(image string, data *CoverageData, outputDir string) error {
	totalFns := make([]string, 0, len(data.TotalFunctions))
	for fn := range data.TotalFunctions {
		totalFns = append(totalFns, fn)
	}
	calledFns := data.CalledFunctions
	totalCount := len(totalFns)
	calledCount := len(calledFns)
	uncalledCount := totalCount - calledCount
	coveragePct := 0.0
	if totalCount > 0 {
		coveragePct = float64(calledCount) / float64(totalCount) * 100
	}
	functions := make([]FunctionEntry, 0, totalCount)
	for _, fn := range totalFns {
		status := "uncalled"
		if _, ok := calledFns[fn]; ok {
			status = "called"
		}
		functions = append(functions, FunctionEntry{Name: fn, Status: status})
	}
	reportData := HTMLReportData{
		ImageName:          image,
		TotalCount:         totalCount,
		CalledCount:        calledCount,
		UncalledCount:      uncalledCount,
		CoveragePercentage: coveragePct,
		Functions:          functions,
	}
	tmpl, err := template.New("report").Parse(htmlTemplateStr)
	if err != nil {
		return err
	}
	safeName := regexp.MustCompile(`[^a-zA-Z0-9._-]`).ReplaceAllString(filepath.Base(image), "_")
	outfile := filepath.Join(outputDir, fmt.Sprintf("coverage_%s.html", safeName))
	f, err := os.Create(outfile)
	if err != nil {
		return err
	}
	defer f.Close()
	return tmpl.Execute(f, reportData)
}

// --- XUnit XML Report ---

type TestSuites struct {
	XMLName   xml.Name    `xml:"testsuites"`
	TestSuite []TestSuite `xml:"testsuite"`
}
type TestSuite struct {
	Errors   int        `xml:"errors,attr"`
	Failures int        `xml:"failures,attr"`
	Name     string     `xml:"name,attr"`
	Skipped  int        `xml:"skipped,attr"`
	Tests    int        `xml:"tests,attr"`
	TestCase []TestCase `xml:"testcase"`
}
type TestCase struct {
	ClassName string  `xml:"classname,attr"`
	Name      string  `xml:"name,attr"`
	Passed    *Passed `xml:"passed"`
}
type Passed struct {
	Message string `xml:"message,attr"`
	Text    string `xml:",chardata"`
}

func generateXUnitReport(image string, data *CoverageData, outputDir string) error {
	totalFns := make([]string, 0, len(data.TotalFunctions))
	for fn := range data.TotalFunctions {
		totalFns = append(totalFns, fn)
	}
	calledFns := data.CalledFunctions
	totalCount := len(totalFns)
	skippedCount := totalCount - len(calledFns)
	calledList := make([]string, 0, len(calledFns))
	uncalledList := make([]string, 0, skippedCount)
	for fn := range data.TotalFunctions {
		if _, ok := calledFns[fn]; ok {
			calledList = append(calledList, fn)
		} else {
			uncalledList = append(uncalledList, fn)
		}
	}
	safeName := regexp.MustCompile(`[^a-zA-Z0-9._-]`).ReplaceAllString(filepath.Base(image), "_")
	outfile := filepath.Join(outputDir, fmt.Sprintf("coverage_%s.xml", safeName))

	summary := fmt.Sprintf("Coverage Summary for %s | Total Functions: %d | Called Functions: %d | Uncalled Functions: %d | Coverage: %.2f%%",
		safeName, totalCount, len(calledFns), skippedCount, float64(len(calledFns))/float64(totalCount)*100)
	var details strings.Builder
	if len(calledList) > 0 {
		details.WriteString("CALLED FUNCTIONS:\n")
		for _, fn := range calledList {
			details.WriteString(fmt.Sprintf("  ✓ %s\n", fn))
		}
		details.WriteString("\n")
	}
	if len(uncalledList) > 0 {
		details.WriteString("UNCALLED FUNCTIONS:\n")
		for _, fn := range uncalledList {
			details.WriteString(fmt.Sprintf("  ✗ %s\n", fn))
		}
	}
	ts := TestSuites{
		TestSuite: []TestSuite{
			{
				Errors:   0,
				Failures: 0,
				Name:     "binary_coverage_" + safeName,
				Skipped:  skippedCount,
				Tests:    totalCount,
				TestCase: []TestCase{
					{
						ClassName: "binary_coverage_" + safeName,
						Name:      "Result",
						Passed: &Passed{
							Message: summary,
							Text:    details.String(),
						},
					},
				},
			},
		},
	}
	f, err := os.Create(outfile)
	if err != nil {
		return err
	}
	defer f.Close()
	enc := xml.NewEncoder(f)
	enc.Indent("", "  ")
	return enc.Encode(ts)
}

// --- CLI ---

func printHelp() {
	fmt.Println(`Usage:
  wrap /path/to/binary
      Wrap the given ELF binary with the Pin coverage wrapper.

  unwrap /path/to/binary
      Restore the original binary previously wrapped.

  report <logdir> [html,xml,txt] [--outdir DIR]
      Generate coverage reports from log files.
      <logdir>           Directory containing .log files (all will be used)
      html/xml/txt       One or more output formats (at least one required)
      --outdir DIR       Output directory for reports (default: current directory)

  help
      Show this help message.

  version
      Show program version.`)
}

func printVersion() {
	fmt.Println("binarycoverage version", versionString)
}

func main() {
	if len(os.Args) < 2 {
		printHelp()
		os.Exit(1)
	}
	switch os.Args[1] {
	case "help", "--help", "-h":
		printHelp()
		return
	case "version", "--version", "-v":
		printVersion()
		return
	case "wrap":
		if len(os.Args) < 3 {
			fmt.Println("wrap: missing binary path")
			os.Exit(1)
		}
		if err := wrap(os.Args[2]); err != nil {
			fmt.Println("wrap error:", err)
			os.Exit(1)
		}
	case "unwrap":
		if len(os.Args) < 3 {
			fmt.Println("unwrap: missing binary path")
			os.Exit(1)
		}
		if err := unwrap(os.Args[2]); err != nil {
			fmt.Println("unwrap error:", err)
			os.Exit(1)
		}
	case "report":
		if len(os.Args) < 3 {
			fmt.Println("report: missing log files argument")
			os.Exit(1)
		}
		logsArg := os.Args[2]
		formats := []string{}
		outdir := "."

		if len(os.Args) < 4 {
			fmt.Println("report: must specify formats as a comma-separated list (e.g. txt,html)")
			os.Exit(1)
		}
		formats = strings.Split(os.Args[3], ",")
		// Parse remaining args for --outdir
		for i := 4; i < len(os.Args); i++ {
			arg := os.Args[i]
			if strings.HasPrefix(arg, "--outdir=") {
				outdir = strings.TrimPrefix(arg, "--outdir=")
			} else if arg == "--outdir" && i+1 < len(os.Args) {
				outdir = os.Args[i+1]
				i++
			}
		}
		if len(formats) == 0 {
			fmt.Println("report: must specify at least one of html, xml, txt")
			os.Exit(1)
		}

		logFiles := []string{}
		info, err := os.Stat(logsArg)
		if err == nil && info.IsDir() {
			entries, err := os.ReadDir(logsArg)
			if err != nil {
				fmt.Printf("report: failed to read directory %s: %v\n", logsArg, err)
				os.Exit(1)
			}
			for _, entry := range entries {
				if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".log") {
					logFiles = append(logFiles, filepath.Join(logsArg, entry.Name()))
				}
			}
			if len(logFiles) == 0 {
				fmt.Printf("report: no .log files found in directory %s\n", logsArg)
				os.Exit(1)
			}
		} else {
			logFiles = strings.Split(logsArg, ",")
		}
		coverage, err := analyzeLogs(logFiles)
		if err != nil {
			fmt.Println("report error:", err)
			os.Exit(1)
		}
		for _, format := range formats {
			switch format {
			case "txt":
				printTxtReport(coverage)
			case "html":
				_ = os.MkdirAll(outdir, 0755)
				for image, data := range coverage {
					if err := generateHTMLReport(image, data, outdir); err != nil {
						fmt.Println("HTML report error:", err)
					}
				}
			case "xml":
				_ = os.MkdirAll(outdir, 0755)
				for image, data := range coverage {
					if err := generateXUnitReport(image, data, outdir); err != nil {
						fmt.Println("XUnit report error:", err)
					}
				}
			}
		}
	default:
		fmt.Println("Unknown command:", os.Args[1])
		printHelp()
		os.Exit(1)
	}
}
