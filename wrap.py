#!/usr/bin/env python3

#  wrap.py - A tool to install and uninstall an Intel Pin wrapper for any given binary.


"""
A tool to install and uninstall an Intel Pin wrapper for any given binary.

MODES:
  -i, --install /path/to/binary   : Moves the original binary to a safe location
                                    and replaces it with a wrapper script.

  -u, --uninstall /path/to/binary : Restores the original binary and cleans up.
"""

import argparse
import os
import sys
import shutil
import tempfile
from datetime import datetime
import subprocess

# --- Configuration ---
PIN_ROOT = os.environ.get("PIN_ROOT")
if PIN_ROOT is None:
    print("Error: PIN_ROOT environment variable is not set.\nPlease set PIN_ROOT to the root of your Intel Pin installation.", file=sys.stderr)
    sys.exit(1)

# Ensure the script is run as root
if os.geteuid() != 0:
    print("Error: This script must be run as root.", file=sys.stderr)
    sys.exit(1)

SAFE_BIN_DIR = os.environ.get("SAFE_BIN_DIR", "/var/coverage/bin")
LOG_DIR = os.environ.get("LOG_DIR", "/var/coverage/data")
PIN_TOOL_SEARCH_DIR = os.environ.get("PIN_TOOL_SEARCH_DIR", "/usr/lib64/coverage-tools")
WRAPPER_ID_COMMENT = "# Pin Wrapper generated by wrap.sh"

def error(msg):
    print(f"Error: {msg}", file=sys.stderr)
    sys.exit(1)

def find_pin_tool():
    for root, _, files in os.walk(PIN_TOOL_SEARCH_DIR):
        if "FuncTracer.so" in files:
            return os.path.join(root, "FuncTracer.so")
    return None

def show_help():
    print(__doc__)
    print("""
Environment variable overrides:
  PIN_ROOT           : Path to Intel Pin installation (required)
  SAFE_BIN_DIR       : Directory to store original binaries (default: /var/coverage/bin)
  LOG_DIR            : Directory for Pin output logs (default: /var/coverage/data)
  PIN_TOOL_SEARCH_DIR: Directory to search for FuncTracer.so (default: /var/coverage)
""")
    
def handle_install(target_binary, pin_tool):
    if not target_binary:
        error("--install requires a target binary path.")

    # Follow symlink if target_binary is a symlink
    if os.path.islink(target_binary):
        real_target = os.path.realpath(target_binary)
        print(f"Note: '{target_binary}' is a symlink. Wrapping the linked file '{real_target}' instead.")
        target_binary = real_target

    if not os.path.isfile(target_binary):
        error(f"Target '{target_binary}' is not a regular file.")

    # Check if already a wrapper
    with open(target_binary, "r", errors="ignore") as f:
        if WRAPPER_ID_COMMENT in f.read():
            error(f"'{target_binary}' is already a wrapper. Use --uninstall first.")

    os.makedirs(SAFE_BIN_DIR, exist_ok=True)
    random_dir = tempfile.mkdtemp(dir=SAFE_BIN_DIR)
    binary_name = os.path.basename(target_binary)
    moved_binary_path = os.path.join(random_dir, binary_name)

    print(f"--> Moving original binary to '{moved_binary_path}'...")
    shutil.move(target_binary, moved_binary_path)

    print(f"--> Creating new wrapper script at '{target_binary}'...")

    wrapper_script = f"""#!/bin/bash
{WRAPPER_ID_COMMENT} on {datetime.now().isoformat()}
# Original Binary: {moved_binary_path}

# Configuration for the wrapper
PIN_ROOT="${{PIN_ROOT:-{PIN_ROOT}}}"
PIN_TOOL="{pin_tool}"
LOG_DIR="{LOG_DIR}"
ORIGINAL_BINARY="{moved_binary_path}"

mkdir -p "$LOG_DIR"

binary_name=$(basename "$0")
timestamp=$(date "+%Y%m%d-%H%M%S")
nano_seconds=$(date "+%N")
log_file="$LOG_DIR/${{binary_name}}_${{timestamp}}_${{nano_seconds}}.log"

exec "$PIN_ROOT/pin" -t "$PIN_TOOL" -logfile "$log_file" -- "$ORIGINAL_BINARY" "$@"
"""

    with open(target_binary, "w") as f:
        f.write(wrapper_script)
    os.chmod(target_binary, 0o755)
    print(f"Installation complete for '{target_binary}'.")

def handle_uninstall(target_binary):
    if not target_binary:
        error("--uninstall requires a target binary path.")

    if not os.path.isfile(target_binary):
        error(f"'{target_binary}' is not a valid wrapper script. Nothing to uninstall.")

    with open(target_binary, "r", errors="ignore") as f:
        content = f.read()
        if WRAPPER_ID_COMMENT not in content:
            error(f"'{target_binary}' is not a valid wrapper script. Nothing to uninstall.")

    # Extract original binary path
    original_binary_path = None
    for line in content.splitlines():
        if line.startswith("# Original Binary:"):
            original_binary_path = line.split(":", 1)[1].strip()
            break

    if not original_binary_path or not os.path.isfile(original_binary_path):
        error("Could not find original binary path in wrapper or path is invalid.")

    safe_dir = os.path.dirname(original_binary_path)
    print(f"--> Restoring original binary for '{target_binary}'...")
    shutil.move(original_binary_path, target_binary)
    print("    Original binary restored.")

    print(f"--> Cleaning up secure storage directory '{safe_dir}'...")
    try:
        os.rmdir(safe_dir)
    except OSError:
        pass
    print("    Done.")
    print(f"Uninstall complete for '{target_binary}'.")

def main():
    parser = argparse.ArgumentParser(
        description="Install/uninstall Intel Pin wrapper for a binary.",
        usage=__doc__)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-i", "--install", metavar="BINARY", help="Install the instrumentation wrapper for a binary.")
    group.add_argument("-u", "--uninstall", metavar="BINARY", help="Restore the original binary and remove the wrapper.")

    args = parser.parse_args()

    if not PIN_ROOT or not os.path.isdir(PIN_ROOT):
        error("PIN_ROOT environment variable is not set or does not point to a valid directory.\nPlease set PIN_ROOT to the root of your Intel Pin installation.")

    pin_tool = find_pin_tool()
    if not pin_tool:
        error(f"Could not automatically find 'FuncTracer.so' within '{PIN_TOOL_SEARCH_DIR}'.\nPlease ensure the Pin tool is compiled and present in a subdirectory.")
    print(f"    Pin Tool found at: {pin_tool}")

    if args.install:
        handle_install(args.install, pin_tool)
    elif args.uninstall:
        handle_uninstall(args.uninstall)
    else:
        show_help()
        sys.exit(1)

if __name__ == "__main__":
    main()